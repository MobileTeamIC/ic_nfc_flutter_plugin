// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name ICNFCCardReader
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import AVFoundation
import AudioToolbox
import Combine
import CommonCrypto
import CoreGraphics
import CoreNFC
import CoreText
import CryptoKit
import CryptoTokenKit
import Darwin
import DeveloperToolsSupport
import Foundation
@_exported import ICNFCCardReader
import MachO
import ObjectiveC
import OpenSSL
import QuartzCore
import Security
import Swift
import SwiftUI
import UIKit
import Vision
import _Concurrency
import _CoreNFC_UIKit
import _StringProcessing
import _SwiftConcurrencyShims
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public func AESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESECBEncrypt(key: [Swift.UInt8], message: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
public protocol AnimationImageProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  func imageForAsset(asset: ImageAsset) -> CoreGraphics.CGImage?
  #endif
}
public enum SecureMessagingSupportedAlgorithms {
  case DES
  case AES
  public static func == (a: SecureMessagingSupportedAlgorithms, b: SecureMessagingSupportedAlgorithms) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, *)
public class SecureMessaging {
  public init(encryptionAlgorithm: SecureMessagingSupportedAlgorithms = .DES, ksenc: [Swift.UInt8], ksmac: [Swift.UInt8], ssc: [Swift.UInt8])
  @objc deinit
}
extension Vector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct Vector2D : Swift.Codable, Swift.Hashable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: Vector2D, b: Vector2D) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Vector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Vector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class SecurityInfo {
  public func getObjectIdentifier() -> Swift.String
  public func getProtocolOIDString() -> Swift.String
  @objc deinit
}
public enum CoordinateSpace : Swift.Int, Swift.Codable {
  case type2d
  case type3d
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class Animation : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  public init(dictionary: [Swift.String : Any]) throws
  final public let startFrame: AnimationFrameTime
  final public let endFrame: AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 13, macOS 10.15, *)
public enum NFCViewDisplayMessage {
  case requestPresentPassport
  case authenticatingWithPassport(Swift.Int)
  case readingDataGroupProgress(DataGroupId, Swift.Int)
  case error(NFCPassportReaderError)
  case successfulRead
}
@available(iOS 13, macOS 10.15, *)
extension NFCViewDisplayMessage {
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup12 : DataGroup {
  public var issuingAuthority: Swift.String? {
    get
  }
  public var dateOfIssue: Swift.String? {
    get
  }
  public var otherPersonsDetails: Swift.String? {
    get
  }
  public var endorsementsOrObservations: Swift.String? {
    get
  }
  public var taxOrExitRequirements: Swift.String? {
    get
  }
  public var frontImage: [Swift.UInt8]? {
    get
  }
  public var rearImage: [Swift.UInt8]? {
    get
  }
  public var personalizationTime: Swift.String? {
    get
  }
  public var personalizationDeviceSerialNr: Swift.String? {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup13 : DataGroup {
  public static let PREFIX_EID: [Swift.UInt8]
  public static let IDX_FULLNAME: Swift.UInt8
  public static let PREFIX_FULLNAME: [Swift.UInt8]
  public static let IDX_DOB: Swift.UInt8
  public static let PREFIX_DOB: [Swift.UInt8]
  public static let IDX_GENDER: Swift.UInt8
  public static let PREFIX_GENDER: [Swift.UInt8]
  public static let IDX_NATIONALITY: Swift.UInt8
  public static let PREFIX_NATIONALITY: [Swift.UInt8]
  public static let IDX_ETHNICITY: Swift.UInt8
  public static let PREFIX_ETHNICITY: [Swift.UInt8]
  public static let IDX_RELIGION: Swift.UInt8
  public static let PREFIX_RELIGION: [Swift.UInt8]
  public static let IDX_POG: Swift.UInt8
  public static let PREFIX_POG: [Swift.UInt8]
  public static let IDX_POR: Swift.UInt8
  public static let PREFIX_POR: [Swift.UInt8]
  public static let IDX_PERSONAL_IDENTIFICATION: Swift.UInt8
  public static let PREFIX_PERSONAL_IDENTIFICATION: [Swift.UInt8]
  public static let IDX_DATEOFISSUE: Swift.UInt8
  public static let PREFIX_DATEOFISSUE: [Swift.UInt8]
  public static let IDX_DATEOFEXPIRY: Swift.UInt8
  public static let PREFIX_DATEOFEXPIRY: [Swift.UInt8]
  public static let IDX_FAMILY: Swift.UInt8
  public static let PREFIX_FAMILY: [Swift.UInt8]
  public static let PREFIX_FATHERNAME: [Swift.UInt8]
  public static let PREFIX_MOTHERNAME: [Swift.UInt8]
  public static let IDX_PARTNERNAME: Swift.UInt8
  public static let PREFIX_PARTNERNAME: [Swift.UInt8]
  public static let IDX_OLDEID: Swift.UInt8
  public static let PREFIX_OLDEID: [Swift.UInt8]
  public static let IDX_CARDUNK: Swift.UInt8
  public static let PREFIX_UNK: [Swift.UInt8]
  public var eidNumber: Swift.String?
  public var fullName: Swift.String?
  public var dateOfBirth: Swift.String?
  public var gender: Swift.String?
  public var nationality: Swift.String?
  public var ethnicity: Swift.String?
  public var religion: Swift.String?
  public var placeOfOrigin: Swift.String?
  public var placeOfResidence: Swift.String?
  public var personalIdentification: Swift.String?
  public var dateOfIssue: Swift.String?
  public var dateOfExpiry: Swift.String?
  public var fatherName: Swift.String?
  public var motherName: Swift.String?
  public var partnerName: Swift.String?
  public var oldEidNumber: Swift.String?
  public var unkIdNumber: Swift.String?
  public var unkInfo: [Swift.String]
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationPublicKeyInfo : SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  @objc deinit
}
@available(iOS 13, *)
public protocol PassportReaderDelegate {
  func passportReaderSessionDidBecomeActive(_ session: CoreNFC.NFCTagReaderSession, timeout: Swift.Int)
  func passportReaderIdInvalidate(_ session: CoreNFC.NFCTagReaderSession, didInvalidateWithError error: any Swift.Error)
  func passportReaderSessionDidDetect(_ session: CoreNFC.NFCTagReaderSession, didDetect tags: [CoreNFC.NFCTag])
  func passportReaderReadingProgress(dgId: DataGroupId, progress: Swift.Int)
}
@objc @available(iOS 13, *)
public class PassportReader : ObjectiveC.NSObject {
  public var delegate: (any PassportReaderDelegate)?
  public var isActiveAuthentication: Swift.Bool
  public var isChipAuthentication: Swift.Bool
  public var passiveAuthenticationUsesOpenSSL: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init(logLevel: LogLevel = .info, masterListURL: Foundation.URL? = nil)
  #endif
  public func setMasterListURL(_ masterListURL: Foundation.URL)
  public func overrideNFCDataAmountToRead(amount: Swift.Int)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use readPassport( accessKey: ...) instead")
  public func readPassport(mrzKey: Swift.String, tags: [DataGroupId] = [], skipSecureElements: Swift.Bool = true, skipCA: Swift.Bool = false, skipPACE: Swift.Bool = false, customDisplayMessage: ((NFCViewDisplayMessage) -> Swift.String?)? = nil) async throws -> NFCPassportModel
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func readPassport(accessKey: PACEAccessKey, tags: [DataGroupId] = [], skipSecureElements: Swift.Bool = true, skipCA: Swift.Bool = false, skipPACE: Swift.Bool = false, customDisplayMessage: ((NFCViewDisplayMessage) -> Swift.String?)? = nil) async throws -> NFCPassportModel
  #endif
  public func invalidateSession()
  @objc deinit
}
@available(iOS 13, *)
extension PassportReader : CoreNFC.NFCTagReaderSessionDelegate {
  public func tagReaderSessionDidBecomeActive(_ session: CoreNFC.NFCTagReaderSession)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didInvalidateWithError error: any Swift.Error)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didDetect tags: [CoreNFC.NFCTag])
}
extension UIKit.UIColor {
  public var lottieColorValue: Color {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup15 : DataGroup {
  public var rsaPublicKey: Swift.OpaquePointer? {
    get
  }
  public var ecdsaPublicKey: Swift.OpaquePointer? {
    get
  }
  @objc deinit
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: AnimationKeypath
  @objc deinit
}
public protocol Interpolatable : AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
public protocol SpatialInterpolatable : AnyInterpolatable {
  #if compiler(>=5.3) && $NonescapableTypes
  func interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
  #endif
}
public protocol AnyInterpolatable {
  #if compiler(>=5.3) && $NonescapableTypes
  func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
  #endif
}
extension Interpolatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent _: CoreFoundation.CGPoint?, spatialInTangent _: CoreFoundation.CGPoint?) -> Self
  #endif
}
extension SpatialInterpolatable {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
  #endif
}
extension Swift.Double : Interpolatable {
}
extension CoreFoundation.CGFloat : Interpolatable {
}
extension Swift.Float : Interpolatable {
}
extension Interpolatable where Self : Swift.BinaryFloatingPoint {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
extension CoreFoundation.CGRect : Interpolatable {
  public func interpolate(to: CoreFoundation.CGRect, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize : Interpolatable {
  public func interpolate(to: CoreFoundation.CGSize, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGPoint : SpatialInterpolatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public func interpolate(to: CoreFoundation.CGPoint, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> CoreFoundation.CGPoint
  #endif
}
extension Color : Interpolatable {
  public func interpolate(to: Color, amount: CoreFoundation.CGFloat) -> Color
}
extension Vector1D : Interpolatable {
  public func interpolate(to: Vector1D, amount: CoreFoundation.CGFloat) -> Vector1D
}
extension Vector2D : SpatialInterpolatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public func interpolate(to: Vector2D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Vector2D
  #endif
}
extension Vector3D : SpatialInterpolatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public func interpolate(to: Vector3D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Vector3D
  #endif
}
extension Swift.Array : Interpolatable, AnyInterpolatable where Element : Interpolatable {
  public func interpolate(to: [Element], amount: CoreFoundation.CGFloat) -> [Element]
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public static func `default`(for renderingEngine: RenderingEngine) -> LottieBackgroundBehavior
  public static func == (a: LottieBackgroundBehavior, b: LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
}
extension LottieLoopMode : Swift.Equatable {
  public static func == (lhs: LottieLoopMode, rhs: LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency final public class AnimationView : AnimationViewBase {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public init(animation: Animation?, imageProvider: (any AnimationImageProvider)? = nil, textProvider: any AnimationTextProvider = DefaultTextProvider(), fontProvider: any AnimationFontProvider = DefaultFontProvider(), configuration: LottieConfiguration = .shared, logger: LottieLogger = .shared)
  #endif
  @_Concurrency.MainActor @preconcurrency public init(configuration: LottieConfiguration = .shared, logger: LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  #endif
  @_Concurrency.MainActor @preconcurrency final public let configuration: LottieConfiguration
  @_Concurrency.MainActor @preconcurrency final public var valueProviders: [AnimationKeypath : any AnyValueProvider] {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var backgroundBehavior: LottieBackgroundBehavior {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var animation: Animation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var imageProvider: any AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var textProvider: any AnimationTextProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var fontProvider: any AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var loopMode: LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentProgress: AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentFrame: AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public var currentRenderingEngine: RenderingEngine? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func play(completion: LottieCompletionBlock? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: AnimationProgressTime? = nil, toProgress: AnimationProgressTime, loopMode: LottieLoopMode? = nil, completion: LottieCompletionBlock? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: AnimationFrameTime? = nil, toFrame: AnimationFrameTime, loopMode: LottieLoopMode? = nil, completion: LottieCompletionBlock? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, loopMode: LottieLoopMode? = nil, completion: LottieCompletionBlock? = nil)
  #endif
  @_Concurrency.MainActor @preconcurrency final public func stop()
  @_Concurrency.MainActor @preconcurrency final public func pause()
  @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @_Concurrency.MainActor @preconcurrency final public func setValueProvider(_ valueProvider: any AnyValueProvider, keypath: AnimationKeypath)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: AnimationKeypath, atFrame: AnimationFrameTime?) -> Any?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func getOriginalValue(for keypath: AnimationKeypath, atFrame: AnimationFrameTime?) -> Any?
  #endif
  @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: AnimationSubview, forLayerAt keypath: AnimationKeypath)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: AnimationKeypath?) -> CoreFoundation.CGRect?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: AnimationKeypath?) -> CoreFoundation.CGPoint?
  #endif
  @_Concurrency.MainActor @preconcurrency final public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: AnimationKeypath)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> AnimationProgressTime?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> AnimationFrameTime?
  #endif
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(iOS 13.0, *)
@objcMembers public class ICNFCCryptoSwift : ObjectiveC.NSObject {
  @objc public class func generateDigitRandomNumber(length: Swift.Int) -> Swift.String
  @objc public class func generateKeyWithRandomNamespace() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public class func sha256Data(_ input: Swift.String, length: Foundation.NSNumber?) -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public class func encryptWithRSAOAEP(message: Foundation.Data, pemPublicKey: Swift.String) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public class func decryptWithRSAOAEP(cipherText: Foundation.Data, pemPrivateKey: Swift.String) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public class func encryptChaCha20Poly1305(data: Foundation.Data, keyData: Foundation.Data, nonceData: Foundation.Data) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public class func decryptChaCha20Poly1305(encryptedData: Swift.String, key: Foundation.Data, nonce: Foundation.Data) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public class func encryptAESGcm(data: Foundation.Data, keyHex: Swift.String) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public class func decryptAESGcm(encryptedData: Foundation.Data, keyHex: Swift.String) -> Foundation.Data?
  #endif
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedSwitch : AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: Animation, configuration: LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  #endif
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: AnimatedSwitch.CancelBehavior, b: AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var cancelBehavior: AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func setProgressForState(fromProgress: AnimationProgressTime, toProgress: AnimationProgressTime, forOnState: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  #endif
  @_Concurrency.MainActor @preconcurrency override public func animationDidSet()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedButton : AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: Animation, configuration: LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromProgress: AnimationProgressTime, toProgress: AnimationProgressTime, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: UIKit.UIControl.Event)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  #endif
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class COM : DataGroup {
  public var version: Swift.String {
    get
  }
  public var unicodeVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  @objc deinit
}
@objc public protocol ICMRZScannerCodeDelegate {
  @objc func icMRZScannerCodeDismissed(lastStep: ICNFCLastStep)
  @objc func icMRZScannerCodeCompleted(idNumber: Swift.String, birthDate: Swift.String, expiryDate: Swift.String, backImage: UIKit.UIImage, cropImage: UIKit.UIImage)
}
@_inheritsConvenienceInitializers @available(iOS 13.0, *)
@objc @_Concurrency.MainActor @preconcurrency open class ICMRZScannerCodeViewController : ICNFCBaseViewController {
  @objc @_Concurrency.MainActor @preconcurrency weak public var scanMRZCodeDelegate: (any ICMRZScannerCodeDelegate)?
  @objc @_Concurrency.MainActor @preconcurrency public var languageApplication: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var isShowTutorial: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public var isDisableTutorial: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLayoutSubviews()
  @objc @_Concurrency.MainActor @preconcurrency public func deallocCameraSession()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
@available(iOS 13.0, *)
extension ICMRZScannerCodeViewController : QKMRZScannerViewDelegate {
  @_Concurrency.MainActor @preconcurrency public func mrzScannerView(_ mrzScannerView: QKMRZScannerView, didFind scanResult: QKMRZScanResult, mrzLines: [Swift.String])
}
@available(iOS 13.0, *)
extension ICMRZScannerCodeViewController : ICNFCHelpImageDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icNFCHelpImageGotIt()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icNFCHelpImageDismissed()
}
@available(iOS 13.0, *)
extension ICMRZScannerCodeViewController : ICPopupCloseSdkDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icPopupCloseSdkPressedLeft()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icPopupCloseSdkPressedRight()
}
@available(iOS 13.0, *)
extension ICMRZScannerCodeViewController : ICPopupPermissionCameraDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icPopupPermissionCameraPressedLeft()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icPopupPermissionCameraPressedRight()
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup11 : DataGroup {
  public var fullName: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var dateOfBirth: Swift.String? {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var address: Swift.String? {
    get
  }
  public var telephone: Swift.String? {
    get
  }
  public var profession: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var personalSummary: Swift.String? {
    get
  }
  public var proofOfCitizenship: Swift.String? {
    get
  }
  public var tdNumbers: Swift.String? {
    get
  }
  public var custodyInfo: Swift.String? {
    get
  }
  @objc deinit
}
final public class Keyframe<T> {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(_ value: T, spatialInTangent: Vector3D? = nil, spatialOutTangent: Vector3D? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(value: T, time: AnimationFrameTime, isHold: Swift.Bool = false, inTangent: Vector2D? = nil, outTangent: Vector2D? = nil, spatialInTangent: Vector3D? = nil, spatialOutTangent: Vector3D? = nil)
  #endif
  final public let value: T
  final public let time: AnimationFrameTime
  final public let isHold: Swift.Bool
  final public let inTangent: Vector2D?
  final public let outTangent: Vector2D?
  final public let spatialInTangent: Vector3D?
  final public let spatialOutTangent: Vector3D?
  @objc deinit
}
extension Keyframe : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: Keyframe<T>, rhs: Keyframe<T>) -> Swift.Bool
}
extension Keyframe : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class OpenSSLUtils {
  public static func getOpenSSLError() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13, macOS 10.15, *)
  public static func getPublicKeyData(from key: Swift.OpaquePointer) -> [Swift.UInt8]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13, macOS 10.15, *)
  public static func decodePublicKeyFromBytes(pubKeyData: [Swift.UInt8], params: Swift.OpaquePointer) -> Swift.OpaquePointer?
  #endif
  public static func computeSharedSecret(privateKeyPair: Swift.OpaquePointer, publicKey: Swift.OpaquePointer) -> [Swift.UInt8]
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public struct DataGroupHash {
  public var id: Swift.String
  public var sodHash: Swift.String
  public var computedHash: Swift.String
  public var match: Swift.Bool
}
public enum PassportAuthenticationStatus {
  case notDone
  case success
  case failed
  public static func == (a: PassportAuthenticationStatus, b: PassportAuthenticationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class NFCPassportModel {
  public var documentType: Swift.String {
    get
  }
  public var documentSubType: Swift.String {
    get
  }
  public var documentNumber: Swift.String {
    get
  }
  public var issuingAuthority: Swift.String {
    get
  }
  public var documentExpiryDate: Swift.String {
    get
  }
  public var dateOfBirth: Swift.String {
    get
  }
  public var gender: Swift.String {
    get
  }
  public var nationality: Swift.String {
    get
  }
  public var lastName: Swift.String {
    get
  }
  public var firstName: Swift.String {
    get
  }
  public var passportMRZ: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var placeOfBirth: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var residenceAddress: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var phoneNumber: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var personalNumber: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var documentSigningCertificate: X509Wrapper? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var countrySigningCertificate: X509Wrapper? {
    get
  }
  #endif
  public var LDSVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  public var dataGroupsAvailable: [DataGroupId] {
    get
  }
  public var dataGroupsRead: [DataGroupId : DataGroup] {
    get
  }
  public var dataGroupHashes: [DataGroupId : DataGroupHash] {
    get
  }
  public var cardAccess: CardAccess? {
    get
  }
  public var BACStatus: PassportAuthenticationStatus {
    get
  }
  public var PACEStatus: PassportAuthenticationStatus {
    get
  }
  public var chipAuthenticationStatus: PassportAuthenticationStatus {
    get
  }
  public var activeAuthenticationStatus: PassportAuthenticationStatus {
    get
  }
  public var passportCorrectlySigned: Swift.Bool {
    get
  }
  public var documentSigningCertificateVerified: Swift.Bool {
    get
  }
  public var passportDataNotTampered: Swift.Bool {
    get
  }
  public var activeAuthenticationPassed: Swift.Bool {
    get
  }
  public var activeAuthenticationChallenge: [Swift.UInt8] {
    get
  }
  public var activeAuthenticationSignature: [Swift.UInt8] {
    get
  }
  public var verificationErrors: [any Swift.Error] {
    get
  }
  public var isPACESupported: Swift.Bool {
    get
  }
  public var isChipAuthenticationSupported: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var passportImage: UIKit.UIImage? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var signatureImage: UIKit.UIImage? {
    get
  }
  #endif
  public var activeAuthenticationSupported: Swift.Bool {
    get
  }
  public init()
  public init(from dump: [Swift.String : Swift.String])
  public func addDataGroup(_ id: DataGroupId, dataGroup: DataGroup)
  #if compiler(>=5.3) && $NonescapableTypes
  public func getDataGroup(_ id: DataGroupId) -> DataGroup?
  #endif
  public func dumpPassportData(selectedDataGroups: [DataGroupId], includeActiveAuthenticationData: Swift.Bool = false) -> [Swift.String : Swift.String]
  public func getHashesForDatagroups(hashAlgorythm: Swift.String) -> [DataGroupId : [Swift.UInt8]]
  #if compiler(>=5.3) && $NonescapableTypes
  public func verifyPassport(masterListURL: Foundation.URL?, useCMSVerification: Swift.Bool = false)
  #endif
  public func verifyActiveAuthentication(challenge: [Swift.UInt8], signature: [Swift.UInt8])
  @objc deinit
}
public enum LogLevel : Swift.Int, Swift.CaseIterable {
  case verbose
  case debug
  case info
  case warning
  case error
  case none
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias AllCases = [LogLevel]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Log {
  public static var logLevel: LogLevel
  public static var storeLogs: Swift.Bool
  public static var logData: [Swift.String]
  public class func verbose(_ msg: @autoclosure () -> Swift.String)
  public class func debug(_ msg: @autoclosure () -> Swift.String)
  public class func info(_ msg: @autoclosure () -> Swift.String)
  public class func warning(_ msg: @autoclosure () -> Swift.String)
  public class func error(_ msg: @autoclosure () -> Swift.String)
  public class func clearStoredLogs()
  @objc deinit
}
@available(iOS 13, *)
public struct ResponseAPDU {
  public var data: [Swift.UInt8]
  public var sw1: Swift.UInt8
  public var sw2: Swift.UInt8
  public init(data: [Swift.UInt8], sw1: Swift.UInt8, sw2: Swift.UInt8)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class AnimationViewBase : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers public class QKMRZScanResult {
  final public let documentImage: UIKit.UIImage
  final public let documentType: Swift.String
  final public let countryCode: Swift.String
  final public let surnames: Swift.String
  final public let givenNames: Swift.String
  final public let documentNumber: Swift.String
  final public let nationality: Swift.String
  final public let birthDate: Foundation.Date?
  final public let sex: Swift.String?
  final public let expiryDate: Foundation.Date?
  final public let personalNumber: Swift.String
  final public let personalNumber2: Swift.String?
  final public let birthDateString: Swift.String
  final public let expiryDateString: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public var faceImage: UIKit.UIImage? {
    get
  }
  #endif
  @objc deinit
}
public struct QKMRZResult {
  public let documentType: Swift.String
  public let countryCode: Swift.String
  public let surnames: Swift.String
  public let givenNames: Swift.String
  public let documentNumber: Swift.String
  public let nationality: Swift.String
  public let birthDate: Foundation.Date?
  public let sex: Swift.String?
  public let expiryDate: Foundation.Date?
  public let personalNumber: Swift.String
  public let personalNumber2: Swift.String?
  public let birthDateString: Swift.String
  public let expiryDateString: Swift.String
  public let isDocumentNumberValid: Swift.Bool
  public let isBirthDateValid: Swift.Bool
  public let isExpiryDateValid: Swift.Bool
  public let isPersonalNumberValid: Swift.Bool?
  public let allCheckDigitsValid: Swift.Bool
}
extension BERTLV {
  public static func parse(hexString: Swift.String) throws -> [BERTLV]
  public static func parse(bytes: [Swift.UInt8]) throws -> [BERTLV]
}
@available(iOS 13.0, *)
public protocol QKMRZScannerViewDelegate : AnyObject {
  func mrzScannerView(_ mrzScannerView: QKMRZScannerView, didFind scanResult: QKMRZScanResult, mrzLines: [Swift.String])
}
@objc @_inheritsConvenienceInitializers @available(iOS 13.0, *)
@IBDesignable @_Concurrency.MainActor @preconcurrency public class QKMRZScannerView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var isScanning: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var vibrateOnResult: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var cutoutRectCustom: CoreFoundation.CGRect?
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any QKMRZScannerViewDelegate)?
  @_Concurrency.MainActor @preconcurrency public var cutoutRect: CoreFoundation.CGRect {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  #endif
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func prepareForInterfaceBuilder()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @objc @_Concurrency.MainActor @preconcurrency public func startScanning()
  @objc @_Concurrency.MainActor @preconcurrency public func stopScanning()
  @objc @_Concurrency.MainActor @preconcurrency public var isSessionRunning: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency public func removeInputOutput()
  @objc @_Concurrency.MainActor @preconcurrency public func deallocSession()
}
@available(iOS 13.0, *)
extension QKMRZScannerView : AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
}
@available(iOS 13, *)
public class BACHandler {
  public var ksenc: [Swift.UInt8]
  public var ksmac: [Swift.UInt8]
  public var kifd: [Swift.UInt8]
  public init()
  public init(tagReader: TagReader)
  public func performBACAndGetSessionKeys(mrzKey: Swift.String) async throws
  public func sessionKeys(data: [Swift.UInt8]) throws -> ([Swift.UInt8], [Swift.UInt8], [Swift.UInt8])
  @objc deinit
}
public enum ColorFormatDenominator : Swift.Hashable {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: ColorFormatDenominator, b: ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Color : Swift.Hashable {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: ColorFormatDenominator = .One)
  public static func == (a: Color, b: Color) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AnimationCacheProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  func animation(forKey: Swift.String) -> Animation?
  #endif
  func setAnimation(_ animation: Animation, forKey: Swift.String)
  func clearCache()
}
public struct LottieConfiguration : Swift.Hashable {
  public init(renderingEngine: RenderingEngineOption = .mainThread, decodingStrategy: DecodingStrategy = .codable)
  public static var shared: LottieConfiguration
  public var renderingEngine: RenderingEngineOption
  public var decodingStrategy: DecodingStrategy
  public static func == (a: LottieConfiguration, b: LottieConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum RenderingEngineOption : Swift.Hashable {
  case automatic
  case specific(RenderingEngine)
  public static var mainThread: RenderingEngineOption {
    get
  }
  public static var coreAnimation: RenderingEngineOption {
    get
  }
}
public enum RenderingEngine : Swift.Hashable {
  case mainThread
  case coreAnimation
}
extension RenderingEngineOption : Swift.RawRepresentable, Swift.CustomStringConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension RenderingEngine : Swift.RawRepresentable, Swift.CustomStringConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public enum DecodingStrategy : Swift.Hashable {
  case codable
  case dictionaryBased
  public static func == (a: DecodingStrategy, b: DecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.FixedWidthInteger {
  public var hexString: Swift.String {
    get
  }
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public var hexString: Swift.String {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(hexString: Swift.String)
  #endif
}
extension Foundation.Data {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(hexString: Swift.String)
  #endif
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  public init(from decoder: any Swift.Decoder) throws
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension QuartzCore.CALayer {
  @nonobjc public func logLayerTree(withIndent: Swift.Int = 0)
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public init(compatibleAnimation: CompatibleAnimation)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleAnimation: CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public func play()
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  #endif
  @objc @_Concurrency.MainActor @preconcurrency final public func stop()
  @objc @_Concurrency.MainActor @preconcurrency final public func pause()
  @objc @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @objc @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  #endif
  @objc @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor @preconcurrency final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: CompatibleAnimationKeypath)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func getColorValue(for keypath: CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  #endif
  @objc @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: AnimationSubview, forLayerAt keypath: CompatibleAnimationKeypath)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  #endif
  @objc @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
extension Swift.Sequence {
  #if compiler(>=5.3) && $NonescapableTypes
  public func toDictionary<K, V>(_ selector: (Self.Iterator.Element) throws -> (K, V)?) rethrows -> [K : V] where K : Swift.Hashable
  #endif
}
extension Swift.String {
  public var isNumber: Swift.Bool {
    get
  }
}
extension UIKit.UIView {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func applyGradient(with colours: [UIKit.UIColor], locations: [Foundation.NSNumber]? = nil, size: CoreFoundation.CGSize)
  #endif
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func setGradient(with colours: [UIKit.UIColor], size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat)
}
extension UIKit.UIFont {
  public static func icNFCCardReaderRegisterFont(withFilenameString filenameString: Swift.String, bundle: Foundation.Bundle)
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public static let modelName: Swift.String
}
public protocol AnimationFontProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  #endif
}
final public class DefaultFontProvider : AnimationFontProvider {
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  #endif
  @objc deinit
}
public protocol AnimationTextProvider : AnyObject {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
final public class DictionaryTextProvider : AnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
final public class DefaultTextProvider : AnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup7 : DataGroup {
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
public typealias LottieCompletionBlock = (Swift.Bool) -> Swift.Void
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup2 : DataGroup {
  public var nrImages: Swift.Int {
    get
  }
  public var versionNumber: Swift.Int {
    get
  }
  public var lengthOfRecord: Swift.Int {
    get
  }
  public var numberOfFacialImages: Swift.Int {
    get
  }
  public var facialRecordDataLength: Swift.Int {
    get
  }
  public var nrFeaturePoints: Swift.Int {
    get
  }
  public var gender: Swift.Int {
    get
  }
  public var eyeColor: Swift.Int {
    get
  }
  public var hairColor: Swift.Int {
    get
  }
  public var featureMask: Swift.Int {
    get
  }
  public var expression: Swift.Int {
    get
  }
  public var poseAngle: Swift.Int {
    get
  }
  public var poseAngleUncertainty: Swift.Int {
    get
  }
  public var faceImageType: Swift.Int {
    get
  }
  public var imageDataType: Swift.Int {
    get
  }
  public var imageWidth: Swift.Int {
    get
  }
  public var imageHeight: Swift.Int {
    get
  }
  public var imageColorSpace: Swift.Int {
    get
  }
  public var sourceType: Swift.Int {
    get
  }
  public var deviceType: Swift.Int {
    get
  }
  public var quality: Swift.Int {
    get
  }
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
extension BERTLV {
  public enum Error : Foundation.LocalizedError {
    case failedToParseHexString
    case missingLength
    case missingType
    case wrongLongLength
    case valueTooShort
    public static func == (a: BERTLV.Error, b: BERTLV.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct BERTLV : Swift.CustomStringConvertible, Swift.Equatable {
  public let tag: Swift.UInt64
  public let value: [Swift.UInt8]
  public let subTags: [BERTLV]
  public let isConstructed: Swift.Bool
  public let lengthBytes: [Swift.UInt8]
  #if compiler(>=5.3) && $NonescapableTypes
  public var rawTextValue: Swift.String? {
    get
  }
  #endif
  public var bytes: [Swift.UInt8] {
    get
  }
  public var description: Swift.String {
    get
  }
  public static func == (a: BERTLV, b: BERTLV) -> Swift.Bool
}
public struct Vector1D : Swift.Hashable {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
  public static func == (a: Vector1D, b: Vector1D) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Vector3D : Swift.Hashable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public static func == (a: Vector3D, b: Vector3D) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class GradientValueProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(block: @escaping GradientValueProvider.ColorsValueBlock, locations: GradientValueProvider.ColorLocationsBlock? = nil)
  #endif
  public init(_ colors: [Color], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [Color]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [Color] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: ValueProviderStorage<[Swift.Double]> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum NFCPassportReaderError : Swift.Error {
  case ResponseError(Swift.String, Swift.UInt8, Swift.UInt8)
  case InvalidResponse
  case UnexpectedError
  case NFCNotSupported
  case NoConnectedTag
  case D087Malformed
  case InvalidResponseChecksum
  case MissingMandatoryFields
  case CannotDecodeASN1Length
  case InvalidASN1Value
  case UnableToProtectAPDU
  case UnableToUnprotectAPDU
  case UnsupportedDataGroup
  case DataGroupNotRead
  case UnknownTag
  case UnknownImageFormat
  case NotImplemented
  case TagNotValid
  case ConnectionError
  case UserCanceled
  case InvalidMRZKey
  case MoreThanOneTagFound
  case InvalidHashAlgorithmSpecified
  case UnsupportedCipherAlgorithm
  case UnsupportedMappingType
  case PACEError(Swift.String, Swift.String)
  case ChipAuthenticationFailed
  case InvalidDataPassed(Swift.String)
  case NotYetSupported(Swift.String)
  case TagConnectionLost
  case SystemResourceUnavailable
}
@available(iOS 13, macOS 10.15, *)
extension NFCPassportReaderError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@available(iOS 13, macOS 10.15, *)
public enum OpenSSLError : Swift.Error {
  case UnableToGetX509CertificateFromPKCS7(Swift.String)
  case UnableToVerifyX509CertificateForSOD(Swift.String)
  case VerifyAndReturnSODEncapsulatedData(Swift.String)
  case UnableToReadECPublicKey(Swift.String)
  case UnableToExtractSignedDataFromPKCS7(Swift.String)
  case VerifySignedAttributes(Swift.String)
  case UnableToParseASN1(Swift.String)
  case UnableToDecryptRSASignature(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension OpenSSLError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
public enum PassiveAuthenticationError : Swift.Error {
  case UnableToParseSODHashes(Swift.String)
  case InvalidDataGroupHash(Swift.String)
  case SODMissing(Swift.String)
}
extension PassiveAuthenticationError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class NotImplementedDG : DataGroup {
  @objc deinit
}
final public class FloatValueProvider {
  public init(block: @escaping FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: ValueProviderStorage<Vector1D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
final public class PointValueProvider {
  public init(block: @escaping PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: ValueProviderStorage<Vector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension Animation {
  public typealias DownloadClosure = (Animation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any AnimationCacheProvider)? = nil) -> Animation?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func filepath(_ filepath: Swift.String, animationCache: (any AnimationCacheProvider)? = nil) -> Animation?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func asset(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationCache: (any AnimationCacheProvider)? = nil) -> Animation?
  #endif
  public static func from(data: Foundation.Data, strategy: DecodingStrategy = LottieConfiguration.shared.decodingStrategy) throws -> Animation
  #if compiler(>=5.3) && $NonescapableTypes
  public static func loadedFrom(url: Foundation.URL, closure: @escaping Animation.DownloadClosure, animationCache: (any AnimationCacheProvider)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func progressTime(forMarker named: Swift.String) -> AnimationProgressTime?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func frameTime(forMarker named: Swift.String) -> AnimationFrameTime?
  #endif
  final public func progressTime(forFrame frameTime: AnimationFrameTime, clamped: Swift.Bool = true) -> AnimationProgressTime
  final public func frameTime(forProgress progressTime: AnimationProgressTime) -> AnimationFrameTime
  final public func time(forFrame frameTime: AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> AnimationFrameTime
}
@_inheritsConvenienceInitializers @objc public class EmulatorChecker : ObjectiveC.NSObject {
  @objc public static func amIRunInEmulator() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class JailbreakChecker : ObjectiveC.NSObject {
  @objc public static func amIJailbroken() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public typealias FailedCheckType = (check: FailedCheck, failMessage: Swift.String)
public enum FailedCheck : Swift.CaseIterable {
  case urlSchemes
  case existenceOfSuspiciousFiles
  case suspiciousFilesCanBeOpened
  case restrictedDirectoriesWriteable
  case fork
  case symbolicLinks
  case dyld
  case openedPorts
  case pSelectFlag
  case suspiciousObjCClasses
  public static func == (a: FailedCheck, b: FailedCheck) -> Swift.Bool
  public typealias AllCases = [FailedCheck]
  nonisolated public static var allCases: [FailedCheck] {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func binToHexRep(_ val: [Swift.UInt8], asArray: Swift.Bool = false) -> Swift.String
public func binToHexRep(_ val: Swift.UInt8) -> Swift.String
public func binToHex(_ val: Swift.UInt8) -> Swift.Int
public func binToHex(_ val: [Swift.UInt8]) -> Swift.UInt64
public func binToHex(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.UInt64
public func hexToBin(_ val: Swift.UInt64) -> [Swift.UInt8]
public func binToInt(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.Int
public func binToInt(_ val: [Swift.UInt8]) -> Swift.Int
public func intToBin(_ data: Swift.Int, pad: Swift.Int = 2) -> [Swift.UInt8]
public func hexRepToBin(_ val: Swift.String) -> [Swift.UInt8]
public func xor(_ kifd: [Swift.UInt8], _ response_kicc: [Swift.UInt8]) -> [Swift.UInt8]
public func generateRandomUInt8Array(_ size: Swift.Int) -> [Swift.UInt8]
public func pad(_ toPad: [Swift.UInt8], blockSize: Swift.Int) -> [Swift.UInt8]
public func unpad(_ tounpad: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func mac(algoName: SecureMessagingSupportedAlgorithms, key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func desMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func aesMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func wrapDO(b: Swift.UInt8, arr: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func unwrapDO(tag: Swift.UInt8, wrappedData: [Swift.UInt8]) throws -> [Swift.UInt8]
public func intToBytes(val: Swift.Int, removePadding: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func oidToBytes(oid: Swift.String, replaceTag: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: Swift.ArraySlice<Swift.UInt8>) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: [Swift.UInt8]) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func toAsn1Length(_ data: Swift.Int) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcHash(data: [Swift.UInt8], hashAlgorithm: Swift.String) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA1Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA224Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA256Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA512Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA384Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationInfo : SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
@available(iOS 13, *)
public enum PACEAccessKey {
  case mrz(Swift.String)
  case can(Swift.String)
}
@available(iOS 13, *)
public class PACEHandler {
  public init(cardAccess: CardAccess, tagReader: TagReader) throws
  public func doPACE(accessKey: PACEAccessKey) async throws
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Asset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc public protocol ICNFCReaderChipDelegate {
  @objc func icNFCReaderChipDismissed()
  @objc func icNFCReaderChipCompleted(avatar: UIKit.UIImage, informationDetails: [Swift.String : Swift.String], dataGroups: [Swift.String : Swift.String], chipAuthentication: ICNFCAuthenticationStatus, activeAuthentication: ICNFCAuthenticationStatus)
  @objc func icNFCReadingChip(state: ICNFCReaderState, progress: Swift.Int, error: Swift.String, logError: [Swift.String : Any], retryCount: Swift.Int)
  @objc func icNFCPopupReaderChipDisappear()
}
@_inheritsConvenienceInitializers @available(iOS 13.0, *)
@objc @_Concurrency.MainActor @preconcurrency open class ICNFCReaderChipViewController : ICNFCBaseViewController {
  @objc @_Concurrency.MainActor @preconcurrency public var delegate: (any ICNFCReaderChipDelegate)?
  @objc @_Concurrency.MainActor @preconcurrency public var isShowTutorial: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public var isEnableGotIt: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public var readerCardMode: ReaderCardMode
  @objc @_Concurrency.MainActor @preconcurrency public var idNumber: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var birthDate: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var expiryDate: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var nameVideoHelpNFC: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var nameAnimationStatus: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var readingTagsNFC: [Swift.Int]?
  @objc @_Concurrency.MainActor @preconcurrency public var isActiveAuthentication: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public var isChipAuthentication: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public var isStartNFCReaderOutSide: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency public var textReadyNFC: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var textScanningNFC: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var textFinishNFC: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var textDetectedNFC: Swift.String
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLayoutSubviews()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
@available(iOS 13.0, *)
extension ICNFCReaderChipViewController {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func startIndicatorView()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func stopIndicatorView()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func readOnlySpecificDataOutSide()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func deallocSessionReaderChipNFC()
}
@available(iOS 13.0, *)
extension ICNFCReaderChipViewController : ICNFCHelpFullScreenVideosDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icNFCHelpFullScreenVideosGotIt()
}
@available(iOS 13.0, *)
extension ICNFCReaderChipViewController : ICPopupCloseSdkDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icPopupCloseSdkPressedLeft()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func icPopupCloseSdkPressedRight()
}
@available(iOS 13.0, *)
extension ICNFCReaderChipViewController : PassportReaderDelegate {
  @_Concurrency.MainActor @preconcurrency public func passportReaderSessionDidBecomeActive(_ session: CoreNFC.NFCTagReaderSession, timeout: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func passportReaderIdInvalidate(_ session: CoreNFC.NFCTagReaderSession, didInvalidateWithError error: any Swift.Error)
  @_Concurrency.MainActor @preconcurrency public func passportReaderSessionDidDetect(_ session: CoreNFC.NFCTagReaderSession, didDetect tags: [CoreNFC.NFCTag])
  @_Concurrency.MainActor @preconcurrency public func passportReaderReadingProgress(dgId: DataGroupId, progress: Swift.Int)
}
public enum PACEMappingType {
  case GM
  case IM
  case CAM
  public static func == (a: PACEMappingType, b: PACEMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class PACEInfo : SecurityInfo {
  public static let PARAM_ID_GFP_1024_160: Swift.Int
  public static let PARAM_ID_GFP_2048_224: Swift.Int
  public static let PARAM_ID_GFP_2048_256: Swift.Int
  public static let PARAM_ID_ECP_NIST_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P320_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P512_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P521_R1: Swift.Int
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getVersion() -> Swift.Int
  #if compiler(>=5.3) && $NonescapableTypes
  public func getParameterId() -> Swift.Int?
  #endif
  public func getParameterSpec() throws -> Swift.Int32
  public func getMappingType() throws -> PACEMappingType
  public func getKeyAgreementAlgorithm() throws -> Swift.String
  public func getCipherAlgorithm() throws -> Swift.String
  public func getDigestAlgorithm() throws -> Swift.String
  public func getKeyLength() throws -> Swift.Int
  public func createMappingKey() throws -> Swift.OpaquePointer
  public static func getParameterSpec(stdDomainParam: Swift.Int) throws -> Swift.Int32
  public static func toMappingType(oid: Swift.String) throws -> PACEMappingType
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toDigestAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class ASN1Item : Swift.CustomDebugStringConvertible {
  public init(line: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public func getChild(_ child: Swift.Int) -> ASN1Item?
  #endif
  public func getNumberOfChildren() -> Swift.Int
  public var debugDescription: Swift.String {
    get
  }
  public func clearData()
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class SimpleASN1DumpParser {
  public init()
  public func parse(data: Foundation.Data) throws -> ASN1Item
  public func test()
  @objc deinit
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup14 : DataGroup {
  public var securityInfos: [SecurityInfo] {
    get
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
extension Color : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateType {
  case documentSigningCertificate
  case issuerSigningCertificate
  public static func == (a: CertificateType, b: CertificateType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateItem : Swift.String {
  case fingerprint
  case issuerName
  case subjectName
  case serialNumber
  case signatureAlgorithm
  case publicKeyAlgorithm
  case notBefore
  case notAfter
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class X509Wrapper {
  final public let cert: Swift.OpaquePointer
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(with cert: Swift.OpaquePointer?)
  #endif
  public func getItemsAsDict() -> [CertificateItem : Swift.String]
  public func certToPEM() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func getFingerprint() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getNotBeforeDate() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getNotAfterDate() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSerialNumber() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSignatureAlgorithm() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getPublicKeyAlgorithm() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getIssuerName() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSubjectName() -> Swift.String?
  #endif
  @objc deinit
}
public class BundleImageProvider : AnimationImageProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func imageForAsset(asset: ImageAsset) -> CoreGraphics.CGImage?
  #endif
  @objc deinit
}
public struct AnimationKeypath : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(keypath: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(keys: [Swift.String])
  public static func == (a: AnimationKeypath, b: AnimationKeypath) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class LottieLogger {
  public init(assert: @escaping LottieLogger.Assert = Swift.assert, assertionFailure: @escaping LottieLogger.AssertionFailure = Swift.assertionFailure, warn: @escaping LottieLogger.Warn = { message, _, _ in
    }, info: @escaping LottieLogger.Info = { message in
    })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Info = (_ message: @autoclosure () -> Swift.String) -> Swift.Void
  public static var shared: LottieLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func info(_ message: @autoclosure () -> Swift.String = String())
  @objc deinit
}
extension LottieLogger {
  public static var printToConsole: LottieLogger {
    get
  }
}
@objc public protocol ICNFCQRCodeScannerViewDelegate {
  @objc func qrScanningDidFail()
  @objc func qrScanningSucceededWithImage(_ image: UIKit.UIImage, value: Swift.String)
  @objc func qrScanningDidStop()
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency public class ICNFCQRCodeScannerView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency weak public var delegate: (any ICNFCQRCodeScannerViewDelegate)?
  @objc @_Concurrency.MainActor @preconcurrency public var captureSession: AVFoundation.AVCaptureSession!
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var layer: AVFoundation.AVCaptureVideoPreviewLayer {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @objc deinit
}
extension ICNFCQRCodeScannerView {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var isSessionRunning: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func startScanning()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func stopScanning()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func resetDataToRescan()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func removeInputOutput()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func deallocSession()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func doInitialSetup(scanRect: CoreFoundation.CGRect)
}
extension ICNFCQRCodeScannerView : AVFoundation.AVCaptureMetadataOutputObjectsDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func metadataOutput(_ output: AVFoundation.AVCaptureMetadataOutput, didOutput metadataObjects: [AVFoundation.AVMetadataObject], from connection: AVFoundation.AVCaptureConnection)
}
extension ICNFCQRCodeScannerView : AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class CardAccess {
  public var securityInfos: [SecurityInfo] {
    get
  }
  @objc deinit
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  var typeErasedStorage: AnyValueProviderStorage { get }
  func hasUpdate(frame: AnimationFrameTime) -> Swift.Bool
}
extension AnyValueProvider {
  public func value(frame: AnimationFrameTime) -> Any
}
public enum ValueProviderStorage<T> where T : AnyInterpolatable {
  case singleValue(T)
  case keyframes([Keyframe<T>])
  case closure((AnimationFrameTime) -> T)
}
public enum AnyValueProviderStorage {
  case singleValue(Any)
  case keyframes([Keyframe<Any>], interpolate: (AnimationFrameTime) -> Any)
  case closure((AnimationFrameTime) -> Any)
}
public class LRUAnimationCache : AnimationCacheProvider {
  public init()
  public static let sharedCache: LRUAnimationCache
  public var cacheSize: Swift.Int
  public func clearCache()
  #if compiler(>=5.3) && $NonescapableTypes
  public func animation(forKey: Swift.String) -> Animation?
  #endif
  public func setAnimation(_ animation: Animation, forKey: Swift.String)
  @objc deinit
}
extension AnimationView {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any AnimationImageProvider)? = nil, animationCache: (any AnimationCacheProvider)? = LRUAnimationCache.sharedCache, configuration: LottieConfiguration = .shared)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency convenience public init(filePath: Swift.String, imageProvider: (any AnimationImageProvider)? = nil, animationCache: (any AnimationCacheProvider)? = LRUAnimationCache.sharedCache, configuration: LottieConfiguration = .shared)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL, imageProvider: (any AnimationImageProvider)? = nil, closure: @escaping AnimationView.DownloadClosure, animationCache: (any AnimationCacheProvider)? = LRUAnimationCache.sharedCache, configuration: LottieConfiguration = .shared)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency convenience public init(asset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any AnimationImageProvider)? = nil, animationCache: (any AnimationCacheProvider)? = LRUAnimationCache.sharedCache, configuration: LottieConfiguration = .shared)
  #endif
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
@available(iOS 13, macOS 10.15, *)
public enum DocTypeEnum : Swift.String {
  case TD1
  case TD2
  case OTHER
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup1 : DataGroup {
  public var elements: [Swift.String : Swift.String] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup {
  public var datagroupType: DataGroupId
  public var body: [Swift.UInt8] {
    get
  }
  public var data: [Swift.UInt8] {
    get
  }
  public func hash(_ hashAlgorythm: Swift.String) -> [Swift.UInt8]
  @objc deinit
}
@objc @_Concurrency.MainActor @preconcurrency open class AnimatedControl : UIKit.UIControl {
  @_Concurrency.MainActor @preconcurrency public init(animation: Animation, configuration: LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  #endif
  @_Concurrency.MainActor @preconcurrency open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency final public let animationView: AnimationView
  @_Concurrency.MainActor @preconcurrency public var animation: Animation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setLayer(named: Swift.String, forState: UIKit.UIControl.State)
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any AnyValueProvider, keypath: AnimationKeypath)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ActiveAuthenticationInfo : SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSignatureAlgorithmOIDString() -> Swift.String?
  #endif
  @objc deinit
}
public class QKMRZParser {
  public init(ocrCorrection: Swift.Bool = false)
  #if compiler(>=5.3) && $NonescapableTypes
  public func parse(mrzLines: [Swift.String]) -> QKMRZResult?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func parse(mrzString: Swift.String) -> QKMRZResult?
  #endif
  @objc deinit
}
public class FilepathImageProvider : AnimationImageProvider {
  public init(filepath: Swift.String)
  public init(filepath: Foundation.URL)
  #if compiler(>=5.3) && $NonescapableTypes
  public func imageForAsset(asset: ImageAsset) -> CoreGraphics.CGImage?
  #endif
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class ICNFCConstant : ObjectiveC.NSObject {
  @objc public static let FontRegular: Swift.String
  @objc public static let FontMedium: Swift.String
  @objc public static let FontBold: Swift.String
  @objc public static let IsIpad: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
final public class SizeValueProvider {
  public init(block: @escaping SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: ValueProviderStorage<Vector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum DataGroupId : Swift.Int, Swift.CaseIterable {
  case COM
  case DG1
  case DG2
  case DG3
  case DG4
  case DG5
  case DG6
  case DG7
  case DG8
  case DG9
  case DG10
  case DG11
  case DG12
  case DG13
  case DG14
  case DG15
  case DG16
  case SOD
  case Unknown
  public func getName() -> Swift.String
  public static func getIDFromName(name: Swift.String) -> DataGroupId
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(iOS 13, macOS 10.15, *)
  public typealias AllCases = [DataGroupId]
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [DataGroupId] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
final public class ColorValueProvider {
  public init(block: @escaping ColorValueProvider.ColorValueBlock)
  public init(_ color: Color)
  public init(_ keyframes: [Keyframe<Color>])
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> Color
  final public var color: Color {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: ValueProviderStorage<Color> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, *)
public class TagReader {
  @objc deinit
}
extension SecureMessagingSupportedAlgorithms : Swift.Equatable {}
extension SecureMessagingSupportedAlgorithms : Swift.Hashable {}
extension CoordinateSpace : Swift.Equatable {}
extension CoordinateSpace : Swift.Hashable {}
extension CoordinateSpace : Swift.RawRepresentable {}
extension LottieBackgroundBehavior : Swift.Equatable {}
extension LottieBackgroundBehavior : Swift.Hashable {}
extension AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension PassportAuthenticationStatus : Swift.Equatable {}
extension PassportAuthenticationStatus : Swift.Hashable {}
extension LogLevel : Swift.Equatable {}
extension LogLevel : Swift.Hashable {}
extension LogLevel : Swift.RawRepresentable {}
extension LayerType : Swift.Equatable {}
extension LayerType : Swift.Hashable {}
extension LayerType : Swift.RawRepresentable {}
extension MatteType : Swift.Equatable {}
extension MatteType : Swift.Hashable {}
extension MatteType : Swift.RawRepresentable {}
extension BlendMode : Swift.Equatable {}
extension BlendMode : Swift.Hashable {}
extension BlendMode : Swift.RawRepresentable {}
extension BERTLV.Error : Swift.Equatable {}
extension BERTLV.Error : Swift.Hashable {}
extension GradientValueProvider : AnyValueProvider {}
extension FloatValueProvider : AnyValueProvider {}
extension PointValueProvider : AnyValueProvider {}
extension FailedCheck : Swift.Equatable {}
extension FailedCheck : Swift.Hashable {}
extension PACEMappingType : Swift.Equatable {}
extension PACEMappingType : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension CertificateType : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension CertificateType : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension CertificateItem : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension CertificateItem : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension CertificateItem : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension DocTypeEnum : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension DocTypeEnum : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension DocTypeEnum : Swift.RawRepresentable {}
extension SizeValueProvider : AnyValueProvider {}
@available(iOS 13, macOS 10.15, *)
extension DataGroupId : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension DataGroupId : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension DataGroupId : Swift.RawRepresentable {}
extension ColorValueProvider : AnyValueProvider {}
